#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "semantic.h"

// 全局语义上下文
static SemanticContext global_ctx = {0};

// 主入口
void semantic_analysis(ASTNode *root) {
    if (!root) return;
    
    printf("\n=== Starting Semantic Analysis ===\n");
    init_error_collector();
    init_symbol_table();
    
    global_ctx.in_loop = 0;
    global_ctx.in_function = 0;
    global_ctx.return_type = TYPE_NODE_VOID;
    global_ctx.has_return = 0;
    
    check_program(root);
    
    // 显示符号表（调试）
    print_symbol_table();
    
    // 打印错误
    print_all_errors();
    
    if (!has_errors()) {
        printf("\n✓ Semantic analysis passed!\n");
    } else {
        printf("\n✗ Semantic analysis failed with %d errors.\n", error_collector.count);
    }
}

// 检查程序
void check_program(ASTNode *node) {
    if (!node || node->kind != EXT_DEF_LIST) return;
    
    // 遍历外部定义
    ASTNode *current = node;
    while (current) {
        if (current->kind == EXT_DEF_LIST) {
            ASTNode *ext_def = current->ptr[0];
            check_ext_def(ext_def);
            current = current->ptr[1];  // 下一个
        } else {
            break;
        }
    }
}

// 检查外部定义
void check_ext_def(ASTNode *node) {
    if (!node) return;
    
    if (node->kind == EXT_VAR_DEF) {
        // 全局变量定义 - 错误1,3: 检查重复定义在insert_symbol中处理
        DataType type = get_type_from_ast(node->ptr[0]);
        // 这里简化处理，实际需要处理变量列表
    } 
    else if (node->kind == FUNC_DEF) {
        check_func_def(node);
    }
}

// 检查函数定义 - 实现多种错误检查
void check_func_def(ASTNode *node) {
    if (!node || node->kind != FUNC_DEF) return;
    
    ASTNode *spec = node->ptr[0];      // 返回类型
    ASTNode *func_dec = node->ptr[1];  // 函数声明
    ASTNode *body = node->ptr[2];      // 函数体
    
    if (!spec || !func_dec) return;
    
    // 获取函数名和返回类型
    char func_name[32];
    if (func_dec->kind == FUNC_DEC && func_dec->ptr[0]) {
        strcpy(func_name, func_dec->ptr[0]->type_id);
    }
    
    DataType return_type = TYPE_NODE_VOID;
    if (spec->kind == TYPE_NODE_INT) return_type = TYPE_NODE_INT;
    else if (spec->kind == TYPE_NODE_FLOAT) return_type = TYPE_NODE_FLOAT;
    else if (spec->kind == TYPE_NODE_CHAR) return_type = TYPE_NODE_CHAR;
    else if (spec->kind == TYPE_NODE_VOID) return_type = TYPE_NODE_VOID;
    
    // 创建函数符号 - 错误4: 重复定义在insert_symbol中检查
    // 这里简化参数处理
    Symbol *func_sym = create_func_symbol(func_name, return_type, 0, NULL);
    insert_symbol(func_sym);
    
    // 设置上下文
    SemanticContext func_ctx = {0};
    func_ctx.in_function = 1;
    func_ctx.return_type = return_type;
    func_ctx.has_return = 0;
    
    // 进入函数作用域
    enter_scope();
    
    // 处理参数（如果存在）
    if (func_dec->ptr[1]) {  // 参数列表
        // 简化处理：实际需要遍历参数列表
    }
    
    // 检查函数体
    if (body && body->kind == COMP_ST) {
        check_stmt(body, &func_ctx);
    }
    
    // 错误20: 非void函数缺少return语句
    if (return_type != TYPE_NODE_VOID && !func_ctx.has_return) {
        semantic_error(node->pos, 0, ERR_FUNC_NO_RETURN, func_name);
    }
    
    // 退出函数作用域
    exit_scope();
}

// 检查语句 - 实现break/continue等错误检查
void check_stmt(ASTNode *node, SemanticContext *ctx) {
    if (!node || !ctx) return;
    
    switch (node->kind) {
        case COMP_ST: {
            // 进入新作用域
            enter_scope();
            
            // 检查声明部分
            if (node->ptr[0]) {
                // 检查变量定义
            }
            
            // 检查语句部分
            if (node->ptr[1]) {
                ASTNode *stmt_list = node->ptr[1];
                while (stmt_list && stmt_list->kind == STMT_LIST) {
                    check_stmt(stmt_list->ptr[0], ctx);
                    stmt_list = stmt_list->ptr[1];
                }
            }
            
            // 退出作用域
            exit_scope();
            break;
        }
        
        case EXP_STMT:
            if (node->ptr[0]) {
                check_expr(node->ptr[0], ctx);
            }
            break;
            
        case RETURN_STMT: {
            ctx->has_return = 1;
            if (node->ptr[0]) {
                DataType expr_type = get_expr_type(node->ptr[0], ctx);
                // 错误10: 返回类型不匹配
                if (!type_compatible(ctx->return_type, expr_type)) {
                    semantic_error(node->pos, 0, ERR_RETURN_TYPE, "return statement");
                }
            } else if (ctx->return_type != TYPE_NODE_VOID) {
                semantic_error(node->pos, 0, ERR_RETURN_TYPE, "void return in non-void function");
            }
            break;
        }
        
        case IF_STMT: {
            // 检查条件表达式 - 错误17: 条件必须是布尔类型
            if (node->ptr[0]) {
                DataType cond_type = get_expr_type(node->ptr[0], ctx);
                // 简化：认为int可以作为条件
                if (cond_type != TYPE_NODE_INT) {
                    semantic_error(node->ptr[0]->pos, 0, ERR_CONDITION_TYPE, "if condition");
                }
            }
            // 检查then语句
            if (node->ptr[1]) {
                check_stmt(node->ptr[1], ctx);
            }
            break;
        }
        
        case IF_ELSE_STMT: {
            // 检查条件
            if (node->ptr[0]) {
                DataType cond_type = get_expr_type(node->ptr[0], ctx);
                if (cond_type != TYPE_NODE_INT) {
                    semantic_error(node->ptr[0]->pos, 0, ERR_CONDITION_TYPE, "if-else condition");
                }
            }
            // 检查then和else
            if (node->ptr[1]) check_stmt(node->ptr[1], ctx);
            if (node->ptr[2]) check_stmt(node->ptr[2], ctx);
            break;
        }
        
        case WHILE_STMT: {
            // 检查条件
            if (node->ptr[0]) {
                DataType cond_type = get_expr_type(node->ptr[0], ctx);
                if (cond_type != TYPE_NODE_INT) {
                    semantic_error(node->ptr[0]->pos, 0, ERR_CONDITION_TYPE, "while condition");
                }
            }
            // 进入循环上下文
            int saved_in_loop = ctx->in_loop;
            ctx->in_loop = 1;
            // 检查循环体
            if (node->ptr[1]) check_stmt(node->ptr[1], ctx);
            // 恢复上下文
            ctx->in_loop = saved_in_loop;
            break;
        }
        
        case FOR_STMT: {
            // 检查初始化表达式
            if (node->ptr[0]) check_expr(node->ptr[0], ctx);
            // 检查条件
            if (node->ptr[1]) {
                DataType cond_type = get_expr_type(node->ptr[1], ctx);
                if (cond_type != TYPE_NODE_INT) {
                    semantic_error(node->ptr[1]->pos, 0, ERR_CONDITION_TYPE, "for condition");
                }
            }
            // 检查更新表达式
            if (node->ptr[2]) check_expr(node->ptr[2], ctx);
            // 进入循环上下文
            int saved_in_loop = ctx->in_loop;
            ctx->in_loop = 1;
            // 检查循环体
            if (node->ptr[3]) check_stmt(node->ptr[3], ctx);
            // 恢复上下文
            ctx->in_loop = saved_in_loop;
            break;
        }
        
        case BREAK_STMT:
            // 错误11: break不在循环中
            if (!ctx->in_loop) {
                semantic_error(node->pos, 0, ERR_BREAK_OUT_LOOP, "break statement");
            }
            break;
            
        case CONTINUE_STMT:
            // 错误12: continue不在循环中
            if (!ctx->in_loop) {
                semantic_error(node->pos, 0, ERR_CONTINUE_OUT_LOOP, "continue statement");
            }
            break;
            
        default:
            break;
    }
}

// 检查表达式 - 实现类型检查等
void check_expr(ASTNode *node, SemanticContext *ctx) {
    if (!node) return;
    
    switch (node->kind) {
        case ID_NODE: {
            // 错误1: 变量未定义
            Symbol *sym = lookup_symbol(node->type_id);
            if (!sym) {
                semantic_error(node->pos, 0, ERR_UNDEFINED_VAR, node->type_id);
                node->expr_type = TYPE_NODE_INT;  // 默认类型，避免级联错误
            } else {
                node->symbol_ref = sym;
                node->expr_type = sym->type;
                node->is_lvalue = (sym->kind == KIND_VAR || sym->kind == KIND_ARRAY);
            }
            break;
        }
        
        case ASSIGN_EXP: {
            // 检查左值 - 错误13: 对非左值赋值
            if (!check_lvalue(node->ptr[0])) {
                semantic_error(node->pos, 0, ERR_NOT_LVALUE, "assignment left side");
            }
            
            // 检查左右表达式类型
            check_expr(node->ptr[0], ctx);
            check_expr(node->ptr[1], ctx);
            
            DataType left_type = get_expr_type(node->ptr[0], ctx);
            DataType right_type = get_expr_type(node->ptr[1], ctx);
            
            // 错误5,16: 赋值类型不匹配
            if (!type_compatible(left_type, right_type)) {
                semantic_error(node->pos, 0, ERR_ASSIGN_TYPE, "assignment type mismatch");
            }
            
            node->expr_type = left_type;
            node->is_lvalue = 0;
            break;
        }
        
        case BINARY_EXP: {
            check_expr(node->ptr[0], ctx);
            check_expr(node->ptr[1], ctx);
            
            DataType left_type = get_expr_type(node->ptr[0], ctx);
            DataType right_type = get_expr_type(node->ptr[1], ctx);
            
            // 错误5: 操作数类型不匹配
            if (!type_compatible(left_type, right_type)) {
                semantic_error(node->pos, 0, ERR_TYPE_MISMATCH, node->type_id);
            }
            
            // 确定表达式类型
            if (strcmp(node->type_id, "&&") == 0 || strcmp(node->type_id, "||") == 0 ||
                strcmp(node->type_id, "==") == 0 || strcmp(node->type_id, "!=") == 0 ||
                strcmp(node->type_id, "<") == 0 || strcmp(node->type_id, ">") == 0 ||
                strcmp(node->type_id, "<=") == 0 || strcmp(node->type_id, ">=") == 0) {
                node->expr_type = TYPE_NODE_INT;  // 布尔结果用int表示
            } else {
                // 算术运算取较高的类型
                node->expr_type = (left_type > right_type) ? left_type : right_type;
            }
            
            node->is_lvalue = 0;
            break;
        }
        
        case FUNC_CALL: {
            // 错误2: 函数未定义
            char func_name[32];
            if (node->ptr[0] && node->ptr[0]->kind == ID_NODE) {
                strcpy(func_name, node->ptr[0]->type_id);
            }
            
            Symbol *sym = lookup_symbol(func_name);
            if (!sym || sym->kind != KIND_FUNC) {
                semantic_error(node->pos, 0, ERR_UNDEFINED_FUNC, func_name);
                node->expr_type = TYPE_NODE_INT;  // 默认类型
            } else {
                node->symbol_ref = sym;
                node->expr_type = sym->extra.func.return_type;
                
                // 错误8: 参数个数检查（简化）
                // 实际需要检查args链表
            }
            node->is_lvalue = 0;
            break;
        }
        
        case ARRAY_ACCESS: {
            check_expr(node->ptr[0], ctx);  // 数组名
            check_expr(node->ptr[1], ctx);  // 下标
            
            // 错误6: 数组下标非整数
            DataType index_type = get_expr_type(node->ptr[1], ctx);
            if (index_type != TYPE_NODE_INT) {
                semantic_error(node->ptr[1]->pos, 0, ERR_ARRAY_SUBSCRIPT, "array index");
            }
            
            // 错误7: 对非数组变量使用下标
            DataType base_type = get_expr_type(node->ptr[0], ctx);
            // 简化：这里需要知道ptr[0]是否是数组类型
            // 实际应该检查symbol_ref
            
            node->expr_type = TYPE_NODE_INT;  // 简化：假设数组元素是int
            node->is_lvalue = 1;         // 数组元素是左值
            break;
        }
        
        case INT_NODE:
            node->expr_type = TYPE_NODE_INT;
            node->is_lvalue = 0;
            break;
            
        case FLOAT_NODE:
            node->expr_type = TYPE_NODE_FLOAT;
            node->is_lvalue = 0;
            break;
            
        case CHAR_NODE:
            node->expr_type = TYPE_NODE_CHAR;
            node->is_lvalue = 0;
            break;
            
        default:
            node->expr_type = TYPE_NODE_INT;
            node->is_lvalue = 0;
            break;
    }
}

// 获取表达式类型
DataType get_expr_type(ASTNode *node, SemanticContext *ctx) {
    if (!node) return TYPE_NODE_VOID;
    
    // 如果还没检查过，先检查
    if (node->expr_type == TYPE_NODE_VOID) {
        check_expr(node, ctx);
    }
    
    return node->expr_type;
}

// 检查是否为左值
int check_lvalue(ASTNode *node) {
    if (!node) return 0;
    
    // 标识符是左值
    if (node->kind == ID_NODE) {
        Symbol *sym = lookup_symbol(node->type_id);
        return (sym != NULL && (sym->kind == KIND_VAR || sym->kind == KIND_ARRAY));
    }
    
    // 数组元素是左值
    if (node->kind == ARRAY_ACCESS) {
        return 1;
    }
    
    return 0;
}

// 从AST结点获取类型
DataType get_type_from_ast(ASTNode *node) {
    if (!node) return TYPE_NODE_VOID;
    
    switch (node->kind) {
        case TYPE_NODE_INT: return TYPE_NODE_INT;
        case TYPE_NODE_FLOAT: return TYPE_NODE_FLOAT;
        case TYPE_NODE_CHAR: return TYPE_NODE_CHAR;
        case TYPE_NODE_VOID: return TYPE_NODE_VOID;
        default: return TYPE_NODE_INT;
    }
}